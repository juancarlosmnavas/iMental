import fetch from "minipass-fetch";
import Keyv from "keyv";
import { ICacheManager } from "./cacheManager";
/**
 * List of custom headers we add to cached responses before returning.
 */
export declare const customCacheHeaders: {
    localCache: string;
    localCacheKey: string;
    localCacheHash: string;
    localCacheTime: string;
};
/**
 * This is an implementation of the Cache standard for make-fetch-happen using
 * the Keyv storage interface. The primary target is Redis.
 * docs: https://developer.mozilla.org/en-US/docs/Web/API/Cache
 * https://www.npmjs.com/package/keyv
 */
export declare class CacheManagerKeyv<T> implements ICacheManager {
    keyv: any;
    uncacheableRequestHeaders: string[];
    constructor(options?: {
        connection?: string;
        keyvOptions?: Keyv.Options<T>;
        keyvStore?: Keyv.Store<T>;
    });
    addCacheHeaders(resHeaders: any, path: any, key: any, hash: any, time: any): void;
    /**
     * Determines the response to be cached or not.
     *
     * @param response The response to determine ability for caching
     *
     * @returns boolean to cache the response or not
     */
    shouldCache(response: fetch.Response): boolean;
    /**
     * Parses the URL string and sorts query params.
     *
     * @param urlString The URL to be normalized
     *
     * @returns The normalized URL as a string
     */
    normalizeUrl(urlString: string): string;
    /**
     * Generate the cache key for the request to be cached or retrieved.
     *
     * @param req The request to generate a cache key for
     *
     * @returns A string of the cache key
     */
    makeCacheKey(req: fetch.Request): string;
    getMetadataKey(req: fetch.Request): string;
    getContentKey(req: fetch.Request): string;
    /**
     * Check if a cached request is a valid match for a given request.
     *
     * @param req The request to find a cached response for
     * @param cached The cached response
     *
     * @returns true for a match, false for a miss
     */
    matchDetails(req: fetch.Request, cached: fetch.Request): boolean;
    /**
     * Returns a Promise that resolves to the response associated with the first
     * matching request in the Cache object.
     *
     * @param req The request to check for a cached response
     * @param opts Currently for compatibility
     *
     * @returns A valid cached response or undefined
     */
    match(req: fetch.Request, opts?: any): Promise<fetch.Response>;
    /**
     * Takes both a request and its response and adds it to the given cache.
     *
     * @param req The request this is a storing a response for
     * @param response The response to be stored
     * @param opts
     *
     * @returns The response or copy of the response
     */
    put(req: fetch.Request, response: fetch.Response, opts?: any): Promise<fetch.Response>;
    /**
     * Finds the Cache entry whose key is the request, and if found, deletes the
     * Cache entry and returns a Promise that resolves to true. If no Cache entry
     * is found, it returns false.
     *
     * @param req The request to try to delete a cached response for
     * @param opts Compatibility with make-fetch-happen, currently unused
     *
     * @returns true is anything is present to delete, false otherwise
     */
    delete(req: fetch.Request, opts?: any): Promise<boolean>;
    stripUncacheableRequestHeaders(req: fetch.Request): fetch.Request;
}
