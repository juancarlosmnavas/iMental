"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._put = exports._post = exports._patch = exports._delete = exports._get = exports.transformRequestBody = exports.mergeHeaders = exports.getHeaders = exports.logResponse = exports.logFetch = exports.getObjectFromResponse = exports.ResponseError = void 0;
const tslib_1 = require("tslib");
const make_fetch_happen_1 = tslib_1.__importDefault(require("make-fetch-happen"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const fetch_to_curl_1 = tslib_1.__importDefault(require("fetch-to-curl"));
const minipass_fetch_1 = require("minipass-fetch");
const redis_1 = tslib_1.__importDefault(require("@keyv/redis"));
const url_1 = require("url");
const resource_1 = require("./resource");
const sdkLogger_1 = require("./sdkLogger");
var cache_1 = require("make-fetch-happen/cache");
Object.defineProperty(exports, "DefaultCache", { enumerable: true, get: function () { return cache_1.DefaultCache; } });
/**
 * Extends the Error class with the the error being a combination of status code
 * and text retrieved from the response.
 *
 * @class ResponseError
 * @extends Error
 */
class ResponseError extends Error {
    constructor(response) {
        super(`${response.status} ${response.statusText}`);
        this.response = response;
    }
}
exports.ResponseError = ResponseError;
/**
 * Returns the dto object from the given response object on status codes 2xx and
 * 304 (Not Modified). The fetch library make-fetch-happen returns the cached object
 * on 304 response. This method throws error on any other 3xx responses that are not
 * automatically handled by make-fetch-happen.
 *
 * @remarks
 * Refer to https://en.wikipedia.org/wiki/List_of_HTTP_status_codes for more information
 * on HTTP status codes.
 *
 * @param response - A response object either containing a dto or an error
 * @returns The DTO wrapped in a promise
 *
 * @throws a ResponseError if the status code of the response is neither 2XX nor 304
 */
function getObjectFromResponse(response) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (response.ok || response.status === 304) {
            const text = yield response.text();
            // It's ideal to get "{}" for an empty response body, but we won't throw if it's truly empty
            return text ? JSON.parse(text) : {};
        }
        else {
            throw new ResponseError(response);
        }
    });
}
exports.getObjectFromResponse = getObjectFromResponse;
/**
 * Log request/fetch details.
 *
 * @param resource The resource being requested
 * @param fetchOptions The options to the fetch call
 */
function logFetch(resource, fetchOptions) {
    sdkLogger_1.sdkLogger.info(`Request: ${fetchOptions.method.toUpperCase()} ${resource}`);
    sdkLogger_1.sdkLogger.debug(`Fetch Options: ${JSON.stringify(fetchOptions, function reducer(key, val) {
        if (this instanceof redis_1.default && key === "redis") {
            return "<Removed from log by @commerce-apps/core, as it is not serializable>";
        }
        return val;
    }, 2)}\nCurl: ${fetch_to_curl_1.default(resource, fetchOptions)}`);
}
exports.logFetch = logFetch;
/**
 * Log response details.
 *
 * @param response The response received
 */
exports.logResponse = (response) => {
    const successString = response.ok || response.status === 304 ? "successful" : "unsuccessful";
    const msg = `Response: ${successString} ${response.status} ${response.statusText}`;
    sdkLogger_1.sdkLogger.info(msg);
    sdkLogger_1.sdkLogger.debug(`Response Headers: ${JSON.stringify(response.headers.raw(), null, 2)}`);
};
exports.getHeaders = (options) => {
    return (options === null || options === void 0 ? void 0 : options.headers) ? Object.assign({}, options.headers) : {};
};
exports.mergeHeaders = (...allHeaders) => {
    const merged = {};
    for (const head of allHeaders) {
        for (const [key, value] of Object.entries(head)) {
            merged[key] = merged[key] ? `${merged[key]}, ${value}` : value;
        }
    }
    return merged;
};
/**
 * Transforms a request body into a format matching the media type of the request.
 * @param body Unparsed request body
 * @param request Request data
 * @returns Parsed request body that can be used by `fetch`.
 */
exports.transformRequestBody = (body, request) => {
    var _a;
    const contentType = (_a = request.headers) === null || _a === void 0 ? void 0 : _a["content-type"];
    if (!contentType) {
        // Preserve default behavior from versions <= 1.5.4
        return JSON.stringify(body);
    }
    switch (contentType) {
        case "application/json":
            return JSON.stringify(body);
        case "application/x-www-form-urlencoded":
            // The type def for URLSearchParams is restrictive. `Record<string, any>` will work, as the
            // values get cast to strings. In any case, the only API that currently uses this media type
            // is SLAS, and all of their params are strings.
            return new url_1.URLSearchParams(body);
        default:
            // All types used by the APIs are currently covered; this would require stuff
            return body;
    }
};
/**
 * Makes an HTTP call specified by the method parameter with the options passed.
 *
 * @param method - Type of HTTP operation
 * @param options - Details to be used for making the HTTP call and processing
 * the response
 * @returns Either the Response object or the DTO inside it wrapped in a promise,
 * depending upon options.rawResponse
 */
function runFetch(method, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const resource = new resource_1.Resource(options.client.clientConfig.baseUri, options.client.clientConfig.parameters, options.path, options.pathParameters, options.queryParameters).toString();
        // Multiple headers can be specified by using different cases. The `Headers`
        // class handles this automatically. It also normalizes header names to all lower case.
        const headers = new minipass_fetch_1.Headers(options.client.clientConfig.headers);
        for (const [header, value] of new minipass_fetch_1.Headers(options.headers)) {
            // Headers specified on the request will _replace_ those specified on the
            // client, rather than be appended to them.
            headers.set(header, value);
        }
        const fetchOptions = Object.assign(Object.assign(Object.assign({}, options.client.clientConfig.fetchOptions), options.fetchOptions), { 
            // This type assertion is technically inaccurate, as some properties may
            // be missing. Also, Cache uses the browser Request, but ICacheManager uses
            // node-fetch's Request, which has additional properties.
            // This is unlikely to cause issues, but it might? It's probably temporary,
            // anyway, as the latest make-fetch-happen drops support for cacheManager.
            cacheManager: options.client.clientConfig.cacheManager, method: method, 
            // The package `http-cache-semantics` (used by `make-fetch-happen`) expects
            // headers to be plain objects, not instances of Headers.
            // TODO: _.fromPairs can be replaced with Object.fromEntries when support
            // for node v10 is dropped.
            headers: lodash_1.default.fromPairs([...headers]), retry: Object.assign(Object.assign({}, options.client.clientConfig.retrySettings), options.retrySettings) });
        if (typeof options.body !== "undefined") {
            fetchOptions.body = exports.transformRequestBody(options.body, fetchOptions);
        }
        logFetch(resource, fetchOptions);
        const response = yield make_fetch_happen_1.default(resource, fetchOptions);
        exports.logResponse(response);
        return options.rawResponse ? response : getObjectFromResponse(response);
    });
}
/**
 * Performs an HTTP GET operation with the options passed.
 *
 * @param options - Details to be used for making the HTTP call and processing
 * the response
 * @returns Either the Response object or the DTO inside it wrapped in a promise,
 * depending upon options.rawResponse
 */
function _get(options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return runFetch("get", options);
    });
}
exports._get = _get;
/**
 * Performs an HTTP DELETE operation with the options passed.
 *
 * @param options - Details to be used for making the HTTP call and processing
 * the response
 * @returns Either the Response object or the DTO inside it wrapped in a promise,
 * depending upon options.rawResponse
 */
function _delete(options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return runFetch("delete", options);
    });
}
exports._delete = _delete;
/**
 * Performs an HTTP PATCH operation with the options passed.
 *
 * @param options - Details to be used for making the HTTP call and processing
 * the response
 * @returns Either the Response object or the DTO inside it wrapped in a promise,
 * depending upon options.rawResponse
 */
function _patch(options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return runFetch("patch", options);
    });
}
exports._patch = _patch;
/**
 * Performs an HTTP POST operation with the options passed.
 *
 * @param options - Details to be used for making the HTTP call and processing
 * the response
 * @returns Either the Response object or the DTO inside it wrapped in a promise,
 * depending upon options.rawResponse
 */
function _post(options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return runFetch("post", options);
    });
}
exports._post = _post;
/**
 * Performs an HTTP PUT operation with the options passed.
 *
 * @param options - Details to be used for making the HTTP call and processing
 * the response
 * @returns Either the Response object or the DTO inside it wrapped in a promise,
 * depending upon options.rawResponse
 */
function _put(options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return runFetch("put", options);
    });
}
exports._put = _put;
//# sourceMappingURL=staticClient.js.map