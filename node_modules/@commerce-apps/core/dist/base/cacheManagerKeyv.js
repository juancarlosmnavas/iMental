/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheManagerKeyv = exports.customCacheHeaders = void 0;
const tslib_1 = require("tslib");
const url_1 = tslib_1.__importStar(require("url"));
const minipass_fetch_1 = tslib_1.__importDefault(require("minipass-fetch"));
const keyv_1 = tslib_1.__importDefault(require("keyv"));
const ssri_1 = tslib_1.__importDefault(require("ssri"));
const sdkLogger_1 = require("./sdkLogger");
/**
 * List of custom headers we add to cached responses before returning.
 */
exports.customCacheHeaders = {
    localCache: "X-Local-Cache",
    localCacheKey: "X-Local-Cache-Key",
    localCacheHash: "X-Local-Cache-Hash",
    localCacheTime: "X-Local-Cache-Time",
};
/**
 * This is an implementation of the Cache standard for make-fetch-happen using
 * the Keyv storage interface. The primary target is Redis.
 * docs: https://developer.mozilla.org/en-US/docs/Web/API/Cache
 * https://www.npmjs.com/package/keyv
 */
class CacheManagerKeyv {
    constructor(options) {
        this.uncacheableRequestHeaders = ["authorization"];
        if (options === null || options === void 0 ? void 0 : options.keyvStore) {
            this.keyv = new keyv_1.default({ store: options.keyvStore });
        }
        else if (options === null || options === void 0 ? void 0 : options.connection) {
            this.keyv = new keyv_1.default(options.connection, options.keyvOptions);
        }
        else {
            this.keyv = new keyv_1.default(options === null || options === void 0 ? void 0 : options.keyvOptions);
        }
        this.keyv.on("error", sdkLogger_1.sdkLogger.error);
    }
    addCacheHeaders(resHeaders, path, key, hash, time) {
        resHeaders.set(exports.customCacheHeaders.localCache, encodeURIComponent(path));
        resHeaders.set(exports.customCacheHeaders.localCacheKey, encodeURIComponent(key));
        resHeaders.set(exports.customCacheHeaders.localCacheHash, encodeURIComponent(hash));
        resHeaders.set(exports.customCacheHeaders.localCacheTime, new Date(time).toUTCString());
    }
    /**
     * Determines the response to be cached or not.
     *
     * @param response The response to determine ability for caching
     *
     * @returns boolean to cache the response or not
     */
    shouldCache(response) {
        var _a;
        const responseControl = (_a = response.headers
            .get("cache-control")) === null || _a === void 0 ? void 0 : _a.toLowerCase().trim().split(/\s*,\s*/);
        return !(responseControl &&
            (responseControl.includes("private") ||
                responseControl.includes("no-store")));
    }
    /**
     * Parses the URL string and sorts query params.
     *
     * @param urlString The URL to be normalized
     *
     * @returns The normalized URL as a string
     */
    normalizeUrl(urlString) {
        const parsed = new url_1.URL(urlString);
        parsed.searchParams.sort();
        return parsed.toString();
    }
    /**
     * Generate the cache key for the request to be cached or retrieved.
     *
     * @param req The request to generate a cache key for
     *
     * @returns A string of the cache key
     */
    makeCacheKey(req) {
        return this.normalizeUrl(req.url);
    }
    getMetadataKey(req) {
        return `request-cache-metadata:${this.makeCacheKey(req)}`;
    }
    getContentKey(req) {
        return `request-cache:${this.makeCacheKey(req)}`;
    }
    /**
     * Check if a cached request is a valid match for a given request.
     *
     * @param req The request to find a cached response for
     * @param cached The cached response
     *
     * @returns true for a match, false for a miss
     */
    matchDetails(req, cached) {
        const reqUrl = new url_1.URL(this.normalizeUrl(req.url));
        const cacheUrl = new url_1.URL(this.normalizeUrl(cached.url));
        const vary = cached.resHeaders.get("Vary");
        // https://tools.ietf.org/html/rfc7234#section-4.1
        if (vary) {
            // A Vary header field-value of "*" always fails to match.
            if (vary.match(/\*/)) {
                return false;
            }
            else {
                const fieldsMatch = vary.split(/\s*,\s*/).every((field) => {
                    return cached.reqHeaders.get(field) === req.headers.get(field);
                });
                if (!fieldsMatch) {
                    return false;
                }
            }
        }
        if (cached.integrity) {
            return !!ssri_1.default.parse(cached.integrity).match(cached.cacheIntegrity);
        }
        reqUrl.hash = null;
        cacheUrl.hash = null;
        return url_1.default.format(reqUrl) === url_1.default.format(cacheUrl);
    }
    /**
     * Returns a Promise that resolves to the response associated with the first
     * matching request in the Cache object.
     *
     * @param req The request to check for a cached response
     * @param opts Currently for compatibility
     *
     * @returns A valid cached response or undefined
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    match(req, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!req) {
                throw new Error("Valid request object required to match");
            }
            this.stripUncacheableRequestHeaders(req);
            const metadataKey = this.getMetadataKey(req);
            const contentKey = this.getContentKey(req);
            // No match if there's no metadata for this request
            const redisInfo = yield this.keyv.get(metadataKey);
            if (!redisInfo) {
                return;
            }
            // No match if the metadata doesn't match
            if (!this.matchDetails(req, {
                url: redisInfo.metadata.url,
                reqHeaders: new minipass_fetch_1.default.Headers(redisInfo.metadata.reqHeaders),
                resHeaders: new minipass_fetch_1.default.Headers(redisInfo.metadata.resHeaders),
                cacheIntegrity: redisInfo.integrity,
                integrity: opts && opts.integrity,
            })) {
                return;
            }
            sdkLogger_1.sdkLogger.debug(`Response found in cache - metadata key: ${metadataKey}, content key: ${contentKey}`);
            // Add customer headers to the response that include caching info
            const resHeaders = new minipass_fetch_1.default.Headers(redisInfo.metadata.resHeaders);
            this.addCacheHeaders(resHeaders, "", contentKey, redisInfo.integrity, redisInfo.time);
            // Return the response without a body for HEAD requests
            if (req.method === "HEAD") {
                return new minipass_fetch_1.default.Response(null, {
                    url: req.url,
                    headers: resHeaders,
                    status: 200,
                });
            }
            // Get the cached response body
            const body = yield this.keyv.get(contentKey);
            return Promise.resolve(new minipass_fetch_1.default.Response(Buffer.from(body), {
                url: req.url,
                headers: resHeaders,
                status: 200,
                size: redisInfo.size,
            }));
        });
    }
    /**
     * Takes both a request and its response and adds it to the given cache.
     *
     * @param req The request this is a storing a response for
     * @param response The response to be stored
     * @param opts
     *
     * @returns The response or copy of the response
     */
    put(req, response, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    opts) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            opts = opts || {};
            if (!req) {
                throw new Error("Valid request object required to put");
            }
            if (!response) {
                throw new Error("Valid response object required to put");
            }
            this.stripUncacheableRequestHeaders(req);
            const size = (_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a.get("content-length");
            const metadataKey = this.getMetadataKey(req);
            const contentKey = this.getContentKey(req);
            if (!this.shouldCache(response)) {
                return response;
            }
            const cacheOpts = {
                algorithms: opts.algorithms,
                integrity: null,
                metadata: {
                    url: req.url,
                    reqHeaders: req.headers.raw(),
                    resHeaders: response.headers.raw(),
                },
                size,
                time: Date.now(),
            };
            const debugMsg = `Response added to cache - metadata key: ${metadataKey}, content key: ${contentKey}`;
            if (req.method === "HEAD" || response.status === 304) {
                // Update metadata without writing
                const redisInfo = yield this.keyv.get(metadataKey);
                // Providing these will bypass content write
                cacheOpts.integrity = redisInfo.integrity;
                this.addCacheHeaders(response.headers, "", contentKey, redisInfo.integrity, redisInfo.time);
                yield this.keyv.set(metadataKey, cacheOpts);
                sdkLogger_1.sdkLogger.debug(debugMsg);
                return response;
            }
            const body = yield response.text();
            yield this.keyv.set(metadataKey, cacheOpts);
            yield this.keyv.set(contentKey, body);
            sdkLogger_1.sdkLogger.debug(debugMsg);
            return Promise.resolve(new minipass_fetch_1.default.Response(Buffer.from(body), response));
        });
    }
    /**
     * Finds the Cache entry whose key is the request, and if found, deletes the
     * Cache entry and returns a Promise that resolves to true. If no Cache entry
     * is found, it returns false.
     *
     * @param req The request to try to delete a cached response for
     * @param opts Compatibility with make-fetch-happen, currently unused
     *
     * @returns true is anything is present to delete, false otherwise
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars
    delete(req, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!req) {
                throw new Error("Valid request object required to delete");
            }
            this.stripUncacheableRequestHeaders(req);
            const metadataKey = this.getMetadataKey(req);
            const contentKey = this.getContentKey(req);
            const deletedFlag = yield Promise.all([
                this.keyv.delete(metadataKey),
                this.keyv.delete(contentKey),
            ]);
            sdkLogger_1.sdkLogger.debug(`Response deleted from cache - metadata key: ${metadataKey}, content key: ${contentKey}`);
            return deletedFlag.includes(true);
        });
    }
    stripUncacheableRequestHeaders(req) {
        this.uncacheableRequestHeaders.forEach((header) => req.headers.delete(header));
        return req;
    }
}
exports.CacheManagerKeyv = CacheManagerKeyv;
//# sourceMappingURL=cacheManagerKeyv.js.map