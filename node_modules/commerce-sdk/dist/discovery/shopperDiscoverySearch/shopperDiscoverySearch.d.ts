import { BaseClient, ClientConfig, Response } from "@commerce-apps/core";
import type { OperationOptions } from "retry";
import type { RequestInit } from "node-fetch";
export declare namespace ShopperDiscoverySearch {
    type ErrorResponse = {
        type: string;
        title?: string;
        detail?: string;
        instance?: string;
    } & {
        [key: string]: any;
    };
    type Money = {
        currencyMnemonic?: string;
        value?: number;
    } & {
        [key: string]: any;
    };
    type SimpleSearchResult = {
        limit: number;
        hits?: Array<object>;
        offset: any;
        total: any;
    } & {
        [key: string]: any;
    };
    type SearchRequest = {
        limit?: number;
        query: any;
        sorts?: Array<Sort>;
        offset?: any;
    } & {
        [key: string]: any;
    };
    type PaginatedSearchResult = {
        query: any;
        sorts?: Array<Sort>;
        limit: number;
        hits?: Array<object>;
        offset: any;
        total: any;
    } & {
        [key: string]: any;
    };
    type ClosedObject = {} & {
        [key: string]: any;
    };
    type OpenObject = {} & {
        [key: string]: any;
    };
    type NoPropertiesAllowed = {};
    type SpecifiedPropertiesAllowed = {} & {
        [key: string]: any;
    };
    type BoolFilter = {
        filters?: Array<any>;
        operator: string;
    } & {
        [key: string]: any;
    };
    type PaginatedSearchResultBase = {
        query: any;
        sorts?: Array<Sort>;
        limit: number;
        hits?: Array<object>;
        offset: any;
        total: any;
    } & {
        [key: string]: any;
    };
    type MatchAllQuery = {} & {
        [key: string]: any;
    };
    type FilteredQuery = {
        filter: any;
        query: any;
    } & {
        [key: string]: any;
    };
    type QueryFilter = {
        query: any;
    } & {
        [key: string]: any;
    };
    type Query = {
        boolQuery?: BoolQuery;
        filteredQuery?: FilteredQuery;
        matchAllQuery?: MatchAllQuery;
        nestedQuery?: NestedQuery;
        termQuery?: TermQuery;
        textQuery?: TextQuery;
    } & {
        [key: string]: any;
    };
    type TermQuery = {
        fields: Array<string>;
        operator: string;
        values?: Array<any>;
    } & {
        [key: string]: any;
    };
    type TermFilter = {
        field: string;
        operator: string;
        values?: Array<any>;
    } & {
        [key: string]: any;
    };
    type TextQuery = {
        fields: Array<string>;
        searchPhrase: string;
    } & {
        [key: string]: any;
    };
    type Range2Filter = {
        filterMode?: string;
        fromField: string;
        fromInclusive?: boolean;
        fromValue?: any;
        toField: string;
        toInclusive?: boolean;
        toValue?: any;
    } & {
        [key: string]: any;
    };
    type BoolQuery = {
        must?: Array<any>;
        mustNot?: Array<any>;
        should?: Array<any>;
    } & {
        [key: string]: any;
    };
    type SimpleSearchResultBase = {
        limit: number;
        hits?: Array<object>;
        offset: any;
        total: any;
    } & {
        [key: string]: any;
    };
    type NestedQuery = {
        path: string;
        query: any;
        scoreMode?: string;
    } & {
        [key: string]: any;
    };
    type Filter = {
        boolFilter?: BoolFilter;
        queryFilter?: QueryFilter;
        range2Filter?: Range2Filter;
        rangeFilter?: RangeFilter;
        termFilter?: TermFilter;
    } & {
        [key: string]: any;
    };
    type Sort = {
        field: string;
        sortOrder?: string;
    } & {
        [key: string]: any;
    };
    type RangeFilter = {
        field: string;
        from?: any;
        fromInclusive?: boolean;
        to?: any;
        toInclusive?: boolean;
    } & {
        [key: string]: any;
    };
    type SearchRequestBase = {
        limit?: number;
        query: any;
        sorts?: Array<Sort>;
        offset?: any;
    } & {
        [key: string]: any;
    };
    type MoneyMnemonic = {
        currencyMnemonic?: string;
        value?: number;
    } & {
        [key: string]: any;
    };
    type ExpansionAttribute = {
        attributeId: string;
        path: string;
        value: any;
    } & {
        [key: string]: any;
    };
    type PaginationLinks = {
        prev?: Self;
        self: Self;
        next?: Self;
    } & {
        [key: string]: any;
    };
    type ResourceLink = {
        self: Self;
    } & {
        [key: string]: any;
    };
    type Self = {
        href: string;
    };
    type SelfResourceLink = {
        self: Self;
    };
    type Pagination = {
        prev?: Self;
        self: Self;
        next?: Self;
    };
    type ResourceBadRequest = {
        [key: string]: any;
    };
    type ResourceNonReadableHttpMessage = {};
    type ResourceInvalidRequest = {};
    type AuthenticationFailure = {};
    type BaseError = {
        type: string;
        title?: string;
        detail?: string;
        instance?: string;
    };
    type NotFound = {};
    type InvalidRequest = {};
    type AuthorizationFailure = {};
    type BadRequest = {};
    type ServiceUnavailable = {};
    type InternalServerError = {};
    type RateLimitExceeded = {
        requestLimit: any;
        type: string;
        title?: string;
        detail?: string;
        instance?: string;
    };
    type NonReadableHttpMessage = {};
    type AttributesQuery = {
        value: {
            attributes: Array<string>;
            phrase: string;
        } & {
            [key: string]: any;
        };
        queryType: string;
        correctableAttributes?: CorrectableAttributes;
        highlighting?: Highlighting;
    };
    type Highlighting = {
        attributes: Array<string>;
    } & {
        [key: string]: any;
    };
    type PhraseQuery = {
        value: string;
        queryType: string;
        correctableAttributes?: CorrectableAttributes;
        highlighting?: Highlighting;
    };
    type QueryOutput = {
        hits: Array<Result>;
        facets?: Array<FacetOutput>;
        links: PaginationLinks;
        limit: number;
        offset: any;
        total: any;
    };
    type QueryInput = {
        query?: Query;
        refinements?: Array<Refinement>;
        returnedAttributes?: Array<string>;
        grouping?: Grouping;
        facets?: Array<FacetInput>;
        facetRequest?: FacetRequest;
        sorting: Sorting;
    };
    type CorrectableAttributes = {
        attributes: Array<string>;
    } & {
        [key: string]: any;
    };
    type Refinement = {
        attributeId: string;
        refinementType: string;
    } & {
        [key: string]: any;
    };
    type ValueRefinement = {
        values: Array<any>;
        attributeId: string;
        refinementType: string;
    };
    type RangeRefinement = {
        min: any;
        max: any;
        attributeId: string;
        refinementType: string;
    };
    type ValueFacetOutput = {
        values?: Array<ValueFacetOutputEntity>;
        attributeId: string;
        facetType: string;
    };
    type FacetInput = {
        attributeId: string;
        facetType: string;
    } & {
        [key: string]: any;
    };
    type RangeFacetInput = {};
    type RangeFacetOutput = {
        min: any;
        max: any;
        attributeId: string;
        facetType: string;
    };
    type ValueFacetInput = {
        mask?: Array<string>;
        attributeId: string;
        facetType: string;
    };
    type FacetRequest = {
        facetLimit?: any;
        facets?: Array<FacetInput>;
    } & {
        [key: string]: any;
    };
    type ValueFacetOutputEntity = {
        value: string;
        count: any;
    } & {
        [key: string]: any;
    };
    type FacetOutput = {
        attributeId: string;
        facetType: string;
    } & {
        [key: string]: any;
    };
    type Sorting = {
        sortType: string;
    } & {
        [key: string]: any;
    };
    type AttributeSorting = {
        attributeId: string;
        direction: string;
        sortType: string;
    };
    type RelevanceSorting = {};
    type Grouping = {
        groupType: string;
    } & {
        [key: string]: any;
    };
    type AttributeGrouping = {
        attributeId: string;
        returnedAttributes?: Array<string>;
        groupType: string;
    };
    type ItemReference = {
        itemId: string;
        attributes?: Array<ExpansionAttribute>;
    } & {
        [key: string]: any;
    };
    type Highlight = {
        attributeId: string;
        value: string;
    } & {
        [key: string]: any;
    };
    type Result = {
        matchedItem: ItemReference;
        highlights?: Array<Highlight>;
        groupId?: string;
        totalGroupedItems?: any;
        groupedItems?: Array<ItemReference>;
    };
    type Suggestion = {
        phrase: string;
    };
    type Suggestions = {
        recentSearchPhrases?: Array<Suggestion>;
        suggestedSearchPhrases?: Array<Suggestion>;
        popularSearchPhrases?: Array<Suggestion>;
    };
}
/**
* [Shopper Discovery Search](https://developer.salesforce.com/docs/commerce/commerce-api/references?meta=shopper-discovery-search:Summary)
* ==================================
*
* *Einstein-powered product search and search suggestions.*<br />
*
* Simple example:
*
* ```typescript
*   import { Discovery, ClientConfig } from "commerce-sdk";
*   // or
*   const { Discovery, ClientConfig } = require("commerce-sdk");
*
*   const clientConfig: ClientConfig = { ... };
*   const shopperDiscoverySearchClient = new Discovery.ShopperDiscoverySearch(clientConfig);
* ```
*
* Example with shopper auth
* ```typescript
* const clientConfig: ClientConfig = {
*   parameters: {
*     clientId: "XXXXXX",
*     organizationId: "XXXX",
*     shortCode: "XXX",
*     siteId: "XX"
*   }
* };
* token = await helpers.getShopperToken(clientConfig, { type: "guest" });
* clientConfig.headers["authorization"] = token.getBearerHeader();
* const shopperDiscoverySearchClient = new Discovery.ShopperDiscoverySearch(clientConfig);
* ```
*
* <span style="font-size:.7em; display:block; text-align: right">
* API Version: 1.1.6<br />
* Last Updated: <br />
* </span>
* @beta
*
*

*/
export declare class ShopperDiscoverySearch extends BaseClient {
    constructor(config: ClientConfig);
    /**
    * This method retrieves search results for a Channel.
    *
    * If you would like to get a raw Response object use the other retrieveResults function.
    *
    * @param options - An object containing the options for this method.
    * @param parameters - An object containing the parameters for this method.
    * @param organizationId - An identifier for the organization the request is being made by.
    * @param channelId - The unique identifier of a Channel.
    * @param locale -
    * @param offset -
    * @param limit - Maximum records to retrieve per request, not to exceed 240. Defaults to 30.
    * @param headers - An object literal of key value pairs of the headers to be
    * sent with this request.
    * @param body - The data to send as the request body.
    *
    * @returns A promise of type ShopperDiscoverySearch.QueryOutput.
    *
    * @beta
    *
    */
    retrieveResults(options: {
        parameters?: {
            organizationId?: string;
            channelId: string;
            locale: string;
            offset?: any;
            limit?: number;
        };
        retrySettings?: OperationOptions;
        fetchOptions?: RequestInit;
        headers?: {
            [key: string]: string;
        };
        body: ShopperDiscoverySearch.QueryInput;
    }): Promise<ShopperDiscoverySearch.QueryOutput>;
    /**
    * This method retrieves search results for a Channel.
    *
    * @param options - An object containing the options for this method.
    * @param parameters - An object containing the parameters for this method.
    * @param organizationId - An identifier for the organization the request is being made by.
    * @param channelId - The unique identifier of a Channel.
    * @param locale -
    * @param offset -
    * @param limit - Maximum records to retrieve per request, not to exceed 240. Defaults to 30.
    * @param headers - An object literal of key value pairs of the headers to be
    * sent with this request.
    * @param body - The data to send as the request body.
    * @param rawResponse - Set to true to return entire Response object instead of DTO.
    *
    * @returns A promise of type Response if rawResponse is true, a promise of type ShopperDiscoverySearch.QueryOutput otherwise.
    *
    * @beta
    *
    */
    retrieveResults<T extends boolean>(options: {
        parameters?: {
            organizationId?: string;
            channelId: string;
            locale: string;
            offset?: any;
            limit?: number;
        };
        retrySettings?: OperationOptions;
        fetchOptions?: RequestInit;
        headers?: {
            [key: string]: string;
        };
        body: ShopperDiscoverySearch.QueryInput;
    }, rawResponse?: T): Promise<T extends true ? Response : ShopperDiscoverySearch.QueryOutput>;
    /**
    * This method gets suggestions for the user's search activity for a channel.
    *
    * If you would like to get a raw Response object use the other getSuggestions function.
    *
    * @param options - An object containing the options for this method.
    * @param parameters - An object containing the parameters for this method.
    * @param organizationId - An identifier for the organization the request is being made by.
    * @param channelId - The unique identifier of a Channel.
    * @param suggestionTypes - The types of suggestions to return.
    * @param searchText - The optional text to retrieve suggestions for.
    * @param locale -
    * @param headers - An object literal of key value pairs of the headers to be
    * sent with this request.
    *
    * @returns A promise of type ShopperDiscoverySearch.Suggestions.
    *
    * @beta
    *
    */
    getSuggestions(options?: {
        parameters?: {
            organizationId?: string;
            channelId: string;
            suggestionTypes: Array<string>;
            searchText?: string;
            locale: string;
        };
        retrySettings?: OperationOptions;
        fetchOptions?: RequestInit;
        headers?: {
            [key: string]: string;
        };
    }): Promise<ShopperDiscoverySearch.Suggestions>;
    /**
    * This method gets suggestions for the user's search activity for a channel.
    *
    * @param options - An object containing the options for this method.
    * @param parameters - An object containing the parameters for this method.
    * @param organizationId - An identifier for the organization the request is being made by.
    * @param channelId - The unique identifier of a Channel.
    * @param suggestionTypes - The types of suggestions to return.
    * @param searchText - The optional text to retrieve suggestions for.
    * @param locale -
    * @param headers - An object literal of key value pairs of the headers to be
    * sent with this request.
    * @param rawResponse - Set to true to return entire Response object instead of DTO.
    *
    * @returns A promise of type Response if rawResponse is true, a promise of type ShopperDiscoverySearch.Suggestions otherwise.
    *
    * @beta
    *
    */
    getSuggestions<T extends boolean>(options?: {
        parameters?: {
            organizationId?: string;
            channelId: string;
            suggestionTypes: Array<string>;
            searchText?: string;
            locale: string;
        };
        retrySettings?: OperationOptions;
        fetchOptions?: RequestInit;
        headers?: {
            [key: string]: string;
        };
    }, rawResponse?: T): Promise<T extends true ? Response : ShopperDiscoverySearch.Suggestions>;
}
